<?php

/**
 * @file
 * Install file.
 */

use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\search_api\Item\Field;
use Drupal\workflows\Entity\Workflow;
use Drupal\user\Entity\Role;

/**
 * Implements hook_install().
 */
function tide_publication_install() {
  // Don't do anything else during config sync.
  if (\Drupal::isConfigSyncing()) {
    return;
  }

  // Enable Editorial workflow if workflow module is enabled.
  $moduleHandler = \Drupal::service('module_handler');
  if ($moduleHandler->moduleExists('workflows')) {
    $editorial_workflow = Workflow::load('editorial');
    if ($editorial_workflow) {
      $editorial_workflow->getTypePlugin()->addEntityTypeAndBundle('node', 'publication');
      $editorial_workflow->getTypePlugin()->addEntityTypeAndBundle('node', 'publication_page');
      $editorial_workflow->save();
    }
  }

  // Add re-order children permission for roles.
  if (\Drupal::moduleHandler()->moduleExists('entity_hierarchy')) {
    $roles = [
      'approver',
      'editor',
      'site_admin',
    ];
    foreach ($roles as $role_name) {
      $role = Role::load($role_name);
      if ($role) {
        $role->grantPermission('reorder entity_hierarchy children');
        $role->save();
      }
    }
  }

  _tide_publication_update_search_api_index();

  // Enable entity type/bundles for use with scheduled transitions.
  if (\Drupal::moduleHandler()->moduleExists('scheduled_transitions')) {
    $config_factory = \Drupal::configFactory();
    $config = $config_factory->getEditable('scheduled_transitions.settings');
    $bundles = $config->get('bundles');
    if ($bundles) {
      foreach ($bundles as $bundle) {
        $enabled_bundles[] = $bundle['bundle'];
      }
      if (!in_array('publication', $enabled_bundles)) {
        $bundles[] = ['entity_type' => 'node', 'bundle' => 'publication'];
        $config->set('bundles', $bundles)->save();
      }
      if (!in_array('publication_page', $enabled_bundles)) {
        $bundles[] = ['entity_type' => 'node', 'bundle' => 'publication_page'];
        $config->set('bundles', $bundles)->save();
      }
    }
    else {
      $publication_bundles = [
        'publication',
        'publication_page',
      ];
      foreach ($publication_bundles as $bundle) {
        $bundles[] = ['entity_type' => 'node', 'bundle' => $bundle];
        $config->set('bundles', $bundles);
      }
      $config->save();
    }
  }
}

/**
 * Add fields to search API.
 */
function _tide_publication_update_search_api_index() {
  $moduleHandler = \Drupal::service('module_handler');
  if ($moduleHandler->moduleExists('tide_search')) {
    $index_storage = \Drupal::entityTypeManager()
      ->getStorage('search_api_index');
    /** @var \Drupal\search_api\IndexInterface $index */
    $index = $index_storage->load('node');

    // Index the Authors field.
    if (!$index->getField('field_publication_authors')) {
      $field_publication_authors = new Field($index, 'field_publication_authors');
      $field_publication_authors->setType('text');
      $field_publication_authors->setPropertyPath('field_publication_authors');
      $field_publication_authors->setDatasourceId('entity:node');
      $field_publication_authors->setLabel('Publication authors');
      $index->addField($field_publication_authors);
    }

    // Index the Publication date field.
    if (!$index->getField('field_publication_date')) {
      $field_publication_date = new Field($index, 'field_publication_date');
      $field_publication_date->setType('date');
      $field_publication_date->setPropertyPath('field_publication_date');
      $field_publication_date->setDatasourceId('entity:node');
      $field_publication_date->setBoost(1);
      $field_publication_date->setLabel('Date of Publication');
      $index->addField($field_publication_date);
    }

    // Index the Publication entity_reference field.
    if (!$index->getField('field_publication_title')) {
      $field_publication_title = new Field($index, 'field_publication_title');
      $field_publication_title->setType('string');
      $field_publication_title->setPropertyPath('field_publication:entity:title');
      $field_publication_title->setDatasourceId('entity:node');
      $field_publication_title->setBoost(1);
      $field_publication_title->setLabel('Publication » Content » Title');
      $index->addField($field_publication_title);
    }
    if (!$index->getField('field_publication_nid')) {
      $field_publication_nid = new Field($index, 'field_publication_nid');
      $field_publication_nid->setType('integer');
      $field_publication_nid->setPropertyPath('field_publication:entity:nid');
      $field_publication_nid->setDatasourceId('entity:node');
      $field_publication_nid->setBoost(1);
      $field_publication_nid->setLabel('Publication » Content » ID');
      $index->addField($field_publication_nid);
    }
    if (!$index->getField('field_publication_uuid')) {
      $field_publication_uuid = new Field($index, 'field_publication_uuid');
      $field_publication_uuid->setType('string');
      $field_publication_uuid->setPropertyPath('field_publication:entity:uuid');
      $field_publication_uuid->setDatasourceId('entity:node');
      $field_publication_uuid->setBoost(1);
      $field_publication_uuid->setLabel('Publication » Content » UUID');
      $index->addField($field_publication_uuid);
    }

    $index->save();
  }
}

/**
 * Implements hook_update_dependencies().
 */
function tide_publication_update_dependencies() {
  $dependencies['tide_publication'][8001] = ['tide_landing_page' => 8008];

  return $dependencies;
}

/**
 * Add Complex Image component.
 */
function tide_publication_update_8001() {
  $content_types = ['publication', 'publication_pages'];
  foreach ($content_types as $content_type) {
    $field_config = FieldConfig::loadByName('node', $content_type, 'field_landing_page_component');
    if ($field_config) {
      $handler_settings = $field_config->getSetting('handler_settings');
      $handler_settings['target_bundles']['complex_image'] = 'complex_image';
      $field_config->setSetting('handler_settings', $handler_settings);
      $field_config->save();
    }
  }
}

/**
 * Add field_tags into publication node type.
 */
function tide_publication_update_8002() {
  module_load_include('inc', 'tide_core', 'includes/helpers');
  $config_location = [drupal_get_path('module', 'tide_publication') . '/config/install'];
  if (!FieldConfig::loadByName('node', 'publication', 'field_tags')) {
    _tide_import_single_config('field.field.node.publication.field_tags', $config_location, TRUE);
    _tide_import_single_config('core.entity_view_display.node.publication.default', $config_location, TRUE);
    _tide_import_single_config('core.entity_form_display.node.publication.default', $config_location, TRUE);
  }
}

/**
 * Change field_publication_authors from text field to taxonomy_term field.
 */
function tide_publication_update_8003() {
  // Required variables.
  $entity_type = 'node';
  $field_name = 'field_publication_authors';
  $field_storage = FieldStorageConfig::loadByName($entity_type, $field_name);
  // Database contention.
  $database = \Drupal::database();
  // The tables need to be updated.
  $tmp_table_names = [
    'tmp_table' => 'node__field_publication_authors',
    'tmp_revision_table' => 'node_revision__field_publication_authors',
  ];
  // field_publication_authors_target_id column specification.
  $spec = [
    'type' => 'int',
    'length' => 10,
    'unsigned' => TRUE,
  ];
  // Database manipulations.
  foreach ($tmp_table_names as $tmp => $table_name) {
    if ($database->schema()->tableExists($table_name)) {
      // Creates two tmp tables.
      $database->query("CREATE TABLE {$tmp} SELECT * FROM  {$table_name}");
      $database->truncate($table_name)->execute();
      // Adds field_publication_authors_target_id field for holding tids.
      $database->schema()
        ->addField($tmp, 'field_publication_authors_target_id', $spec);
      // Gets tids.
      $terms = $database->select($tmp, 't')
        ->fields('t', ['field_publication_authors_value'])
        ->execute()
        ->fetchCol();
      // Updates field_publication_authors_target_id with correct tid.
      foreach ($terms as $term) {
        $tids = \Drupal::entityQuery('taxonomy_term')
          ->condition('name', $term)
          ->execute();
        if ($tids) {
          $tid = (int) reset($tids);
          $database->update($tmp)
            ->fields(['field_publication_authors_target_id' => $tid])
            ->condition('field_publication_authors_value', $term)
            ->execute();
        }
      }
      // Deletes rows that has no tid associated.
      $database->delete($tmp)
        ->condition('field_publication_authors_target_id', NULL, 'IS')
        ->execute();
      // Delete field_publication_authors_value column.
      $database->schema()->dropField($tmp, 'field_publication_authors_value');

      // Do some changes in field field tables.
      $database->schema()
        ->changeField($table_name, 'field_publication_authors_value', 'field_publication_authors_target_id', $spec);
    }
  }

  // Update FieldStorageConfig.
  $new_field_storage = $field_storage->toArray();
  $new_field_storage['type'] = 'entity_reference';
  $new_field_storage['dependencies'] = [
    'module' => [
      'node',
      'taxonomy',
    ],
  ];
  $new_field_storage['settings'] = ['target_type' => 'taxonomy_term'];
  $new_field_storage['cardinality'] = 1;
  $new_field_storage['module'] = 'core';
  $new_field_storage = FieldStorageConfig::create($new_field_storage);
  $new_field_storage->original = $new_field_storage;
  $new_field_storage->enforceIsNew(FALSE);
  $new_field_storage->save();

  // Update field.
  foreach ($field_storage->getBundles() as $bundle => $label) {
    $field = FieldConfig::loadByName($entity_type, $bundle, $field_name);
    $new_field = $field->toArray();
    $new_field['field_type'] = 'entity_reference';
    $new_field['dependencies'] = [
      'config' => [
        'field.storage.' . $field_storage->id(),
        'node.type.' . $bundle,
        'taxonomy.vocabulary.department',
      ],
    ];
    $new_field['settings'] = [
      'handler_settings' => [
        'target_bundles' => [
          'department' => 'department',
        ],
      ],
    ];
    $new_field = FieldConfig::create($new_field);
    $new_field->original = $field;
    $new_field->enforceIsNew(FALSE);
    $new_field->save();
  }
  // Data migration.
  foreach ($tmp_table_names as $tmp => $table_name) {
    $database->insert($table_name)->from($database->select($tmp, 't')
      ->fields('t'))->execute();
    $database->schema()->dropTable($tmp);
  }
  drupal_flush_all_caches();
}

/**
 * Enable path enhancer.
 */
function tide_publication_update_8004() {
  $moduleHandler = \Drupal::service('module_handler');
  if ($moduleHandler->moduleExists('jsonapi') && $moduleHandler->moduleExists('jsonapi_extras')) {
    $config_factory = \Drupal::configFactory();
    $configs = [
      'jsonapi_extras.jsonapi_resource_config.node--publication',
      'jsonapi_extras.jsonapi_resource_config.node--publication_page',
    ];
    foreach ($configs as $config) {
      $jsonapi_settings = $config_factory->getEditable($config);
      $resource_fields = $jsonapi_settings->get('resourceFields');
      $resource_fields['path']['enhancer']['id'] = 'path_enhancer';
      $jsonapi_settings->set('resourceFields', $resource_fields)->save(TRUE);
    }
  }
}

/**
 * Updating field_publication_authors to give option to add multiple authors.
 */
function tide_publication_update_8005() {
  $config_factory = \Drupal::configFactory();
  $config = $config_factory->getEditable('field.storage.node.field_publication_authors');
  $config->set('cardinality', -1);
  $config->save();
}

/**
 * Add re-order children permission for roles.
 */
function tide_publication_update_8006() {
  if (\Drupal::moduleHandler()->moduleExists('entity_hierarchy')) {
    $roles = [
      'approver',
      'editor',
      'site_admin',
    ];
    foreach ($roles as $role_name) {
      $role = Role::load($role_name);
      if ($role) {
        $role->grantPermission('reorder entity_hierarchy children');
        $role->save();
      }
    }
  }
}

/**
 * Enable entity type/bundles for use with scheduled transitions.
 */
function tide_publication_update_8007() {
  if (\Drupal::moduleHandler()->moduleExists('scheduled_transitions')) {
    $config_factory = \Drupal::configFactory();
    $config = $config_factory->getEditable('scheduled_transitions.settings');
    $bundles = $config->get('bundles');
    if ($bundles) {
      foreach ($bundles as $bundle) {
        $enabled_bundles[] = $bundle['bundle'];
      }
      if (!in_array('publication', $enabled_bundles)) {
        $bundles[] = ['entity_type' => 'node', 'bundle' => 'publication'];
        $config->set('bundles', $bundles)->save();
      }
      if (!in_array('publication_page', $enabled_bundles)) {
        $bundles[] = ['entity_type' => 'node', 'bundle' => 'publication_page'];
        $config->set('bundles', $bundles)->save();
      }
    }
    else {
      $publication_bundles = [
        'publication',
        'publication_page',
      ];
      foreach ($publication_bundles as $bundle) {
        $bundles[] = ['entity_type' => 'node', 'bundle' => $bundle];
        $config->set('bundles', $bundles);
      }
      $config->save();
    }
  }
}

/**
 * Widget change.
 *
 * Changes the field_publication_authors widget to
 * entity_reference_autocomplete_tags type.
 */
function tide_publication_update_8008() {
  /** @var \Drupal\Core\Entity\Display\EntityFormDisplayInterface $entity_form_display */
  $entity_form_display = \Drupal::entityTypeManager()
    ->getStorage('entity_form_display')
    ->load('node.publication.default');
  if ($entity_form_display) {
    $settings = $entity_form_display->getComponent('field_publication_authors');
    if (isset($settings['type']) && $settings['type'] != 'entity_reference_autocomplete') {
      $settings['type'] = 'entity_reference_autocomplete';
      $entity_form_display->setComponent('field_publication_authors', $settings);
      $entity_form_display->save();
    }
  }
}

/**
 * Add field display headings for table of contents.
 */
function tide_publication_update_8009() {
  module_load_include('inc', 'tide_core', 'includes/helpers');
  $config_location = [drupal_get_path('module', 'tide_page') . '/config/install'];
  $new_fields = [
    'field.field.node.publication_page.field_node_display_headings',
    'field.field.node.publication.field_node_display_headings',
  ];
  foreach ($new_fields as $new_field) {
    $config_read = _tide_read_config($new_field, $config_location, TRUE);
    // Obtain the storage manager for field instances.
    // Create a new field instance from the yaml configuration and save.
    \Drupal::entityManager()->getStorage('field_config')
      ->create($config_read)
      ->save();
  }
  $config_factory = \Drupal::configFactory();
  // Add to form display.
  $new_displayss = [
    'core.entity_form_display.node.publication_page.default' => 'field.field.node.publication_page.field_node_display_headings',
    'core.entity_form_display.node.publication.default' => 'field.field.node.publication.field_node_display_headings',
  ];
  foreach ($new_displayss as $display => $field) {
    $config = $config_factory->getEditable($display);

    $dependencies = $config->get('dependencies.config');
    if (!in_array($field, $dependencies)) {
      $dependencies[] = $field;
      $config->set('dependencies.config', $dependencies);
    }
    $group_body_content = 'third_party_settings.field_group.group_body_content.children';
    $third_party_settings = $config->get($group_body_content);
    if (!isset($third_party_settings['field_node_display_headings'])) {
      $third_party_settings = [
        'field_show_table_of_content',
        'field_node_display_headings',
        'field_landing_page_component',
      ];
      $config->set($group_body_content, $third_party_settings);
      if ($display == 'core.entity_form_display.node.publication.default') {
        $third_party_settings[] = 'field_node_documents';
        $config->set($group_body_content, $third_party_settings);
      }
    }
    $table_of_content_weight = $config->get('content.field_show_table_of_content.weight');
    $content = $config->get('content');
    if (!isset($content['field_node_display_headings'])) {
      $content['field_node_display_headings'] = [
        'weight' => $table_of_content_weight + 1,
        'settings' => [],
        'third_party_settings' => [],
        'type' => 'options_buttons',
        'region' => 'content',
      ];
      $config->set('content', $content);
    }
    $config->save();
  }
  // Add Json.
  $json_feilds = [
    'jsonapi_extras.jsonapi_resource_config.node--publication_page',
    'jsonapi_extras.jsonapi_resource_config.node--publication',
  ];
  foreach ($json_feilds as $field) {
    $json_config = $config_factory->getEditable($field);
    $json_content = $json_config->get('resourceFields');
    if (!isset($json_content['field_node_display_headings'])) {
      $json_content['field_node_display_headings'] = [
        'fieldName' => 'field_node_display_headings',
        'publicName' => 'field_node_display_headings',
        'enhancer' => [
          'id' => '',
        ],
        'disabled' => FALSE,
      ];
      $json_config->set('resourceFields', $json_content);
    }
    $config->save();
  }
  // Update show table of content label.
  $fields = [
    'field.field.node.publication_page.field_show_table_of_content',
    'field.field.node.publication.field_show_table_of_content',
  ];
  foreach ($fields as $field) {
    $field_config = $config_factory->getEditable($field);
    $description = 'The table of contents is automatically built from the heading structure of your page.';
    $field_config->set('description', $description);
    $field_config->save();
  }
}